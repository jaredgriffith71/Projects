import os
import asyncio
from collections import deque
from telegram_bot import send_message_to_chat
from telegram_reader import read_telegram_messages
from api_interaction import fetch_wallet_balance

LAST_MESSAGE_ID_FILE = 'last_message_id.txt'
MAX_PAIRS_CACHE = 3  # Maximum number of token-wallet pairs to cache
BURN_SCAN_INTERVAL = 60  # Scan for burns every 60 seconds (1 minute)
BURN_TRACK_DURATION = 3600  # Track tokens for burns for 1 hour (3600 seconds)

class TokenPairQueue:
    def __init__(self, max_size=MAX_PAIRS_CACHE):
        self.queue = deque(maxlen=max_size)

    def add_pair(self, pair):
        self.queue.append(pair)

    def contains(self, pair):
        return pair in self.queue

def get_last_message_id():
    if os.path.exists(LAST_MESSAGE_ID_FILE):
        with open(LAST_MESSAGE_ID_FILE, 'r') as file:
            return int(file.read().strip())
    return None

def set_last_message_id(message_id):
    with open(LAST_MESSAGE_ID_FILE, 'w') as file:
        file.write(str(message_id))

def check_creator_wallet_percentage(total_supply, creator_balance):
    try:
        percentage_held = (creator_balance / total_supply) * 100
        return 20 <= percentage_held <= 30
    except ZeroDivisionError:
        print("Total supply cannot be zero.")
        return False

class BurnTracker:
    def __init__(self):
        self.tracked_tokens = {}

    def add_token(self, token_address, total_supply, creator_balance):
        self.tracked_tokens[token_address] = {
            'total_supply': total_supply,
            'creator_balance': creator_balance,
            'last_checked': 0,  # Timestamp of the last check
            'end_time': asyncio.get_event_loop().time() + BURN_TRACK_DURATION  # Track for 1 hour
        }

    def is_tracking(self, token_address):
        return token_address in self.tracked_tokens

    def remove_expired_tokens(self):
        current_time = asyncio.get_event_loop().time()
        self.tracked_tokens = {k: v for k, v in self.tracked_tokens.items() if v['end_time'] > current_time}

    def update_last_checked(self, token_address):
        if token_address in self.tracked_tokens:
            self.tracked_tokens[token_address]['last_checked'] = asyncio.get_event_loop().time()

    def get_tracked_tokens(self):
        return self.tracked_tokens

async def scan_for_burns(burn_tracker):
    while True:
        burn_tracker.remove_expired_tokens()

        for token_address, data in burn_tracker.get_tracked_tokens().items():
            if asyncio.get_event_loop().time() - data['last_checked'] >= BURN_SCAN_INTERVAL:
                # Fetch the current total supply and check for burns
                current_total_supply = fetch_wallet_balance(token_address, token_address, api_key)  # Assuming total supply can be fetched like this
                burn_amount = data['total_supply'] - current_total_supply
                if burn_amount >= data['creator_balance']:
                    message_text = f"ALERT: Burn detected for token {token_address}.\nBurn Amount: {burn_amount}"
                    await send_message_to_chat(message_text)
                    print(f"Burn detected for {token_address}. Burn amount: {burn_amount}")
                burn_tracker.update_last_checked(token_address)

        await asyncio.sleep(BURN_SCAN_INTERVAL)

api_key = '7f1a9f41-aa9d-41ac-84c9-6b879c5dd8eb'
api_id = '24855421'
api_hash = '6a5d75ba93e747bf2411533f00237db6'
phone_number = '+19419610694'
channel_name = 'SolanaNewPumpfun'

async def process_message(message_id, token_name, token_address, wallet_address, total_supply, pair_queue, wallet_cache, burn_tracker):
    print(f"\n---\nProcessing Token: {token_name}\nToken Address: {token_address}\nWallet: {wallet_address}\nTotal Supply: {total_supply}")

    if pair_queue.contains((wallet_address, token_address)):
        print(f"Skipping already processed message ID: {message_id}")
        return

    # Introduce a delay before making the API call
    await asyncio.sleep(5)

    cache_key = (wallet_address, token_address)
    creator_balance = fetch_wallet_balance(wallet_address, token_address, api_key)
    if creator_balance is not None:
        wallet_cache[cache_key] = creator_balance
        print(f"Token Balance: {creator_balance}")
    else:
        print(f"Failed to fetch balance for wallet {wallet_address}")
        return

    if check_creator_wallet_percentage(float(total_supply), creator_balance):
        message_text = (
            f"ALERT: Wallet holds 20-30% of supply.\n\n"
            f"Ticker: {token_name}\n\n"
            f"<a href='https://solscan.io/account/{wallet_address}'>DEP: </a>"
            f"<code>{wallet_address}</code>\n\n"
            f"CA: <code>{token_address}</code>\n\n"
            f"Token Balance: <b>{creator_balance}</b>\n\n"
            f"<a href='https://bullx.io/terminal?chainId=1399811149&address={token_address}'>Bullx</a>"
            f" Â¬ "
            f"<a href='https://photon-sol.tinyastro.io/en/lp/{token_address}'>Photon</a>"
        )
        print(f"\n---\n{message_text}\n---")
        await send_message_to_chat(message_text)

        # Add token to burn tracker
        if not burn_tracker.is_tracking(token_address):
            burn_tracker.add_token(token_address, float(total_supply), creator_balance)
            print(f"Started burn tracking for token {token_address}.")
    else:
        print("Creator's wallet does not hold between 20% and 30% of the total supply.")

    # Add the pair to the recently processed queue
    pair_queue.add_pair((wallet_address, token_address))

async def main():
    last_message_id = get_last_message_id()
    wallet_cache = {}
    pair_queue = TokenPairQueue(MAX_PAIRS_CACHE)
    burn_tracker = BurnTracker()

    if last_message_id is None:
        async for message_id, *_ in read_telegram_messages(api_id, api_hash, phone_number, channel_name, None):
            last_message_id = message_id
            set_last_message_id(last_message_id)
            break

    # Start burn scanning task in the background
    asyncio.create_task(scan_for_burns(burn_tracker))

    while True:
        async for message_id, token_address, wallet_address, total_supply, token_name in read_telegram_messages(api_id, api_hash, phone_number, channel_name, last_message_id):
            if message_id <= last_message_id:
                continue

            set_last_message_id(message_id)

            # Process each message and manage the queue
            await process_message(message_id, token_name, token_address, wallet_address, total_supply, pair_queue, wallet_cache, burn_tracker)
            await asyncio.sleep(2)  # Staggering the processing with a delay of 2 seconds

            # Ensure only the first scan outputs results
            if len(pair_queue.queue) == MAX_PAIRS_CACHE:
                print(f"Queue full. Message {pair_queue.queue[0]} will be removed on the next incoming message.")

        print("Waiting for new messages...")
        await asyncio.sleep(3)

if __name__ == "__main__":
    asyncio.run(main())
